# genai-tag-db-tools Implementation Guidelines

This file provides structured implementation guidelines for genai-tag-db-tools development.

## Implementation Workflow

### 1. Pre-Implementation Checklist
Before writing code, ensure:

- [ ] Database schema impact is understood
- [ ] Migration strategy is planned
- [ ] Implementation plan is approved
- [ ] Test strategy is defined
- [ ] External integration impact is assessed

### 2. Database-First Development
Follow database-first development principles:

- **Schema Changes First**: Implement database changes before application logic
- **Migration Testing**: Test migrations with sample data
- **Transaction Boundaries**: Define clear transaction scopes
- **Data Validation**: Implement database-level constraints
- **Performance Monitoring**: Profile database operations

### 3. Service Layer Implementation
Implement business logic in service layer:

- **Repository Pattern**: Use repository pattern for data access
- **Transaction Management**: Handle database transactions properly
- **Error Handling**: Implement comprehensive error handling
- **Input Validation**: Validate all inputs before database operations
- **Performance Optimization**: Optimize for bulk operations

### 4. GUI Integration
Integrate with existing GUI framework:

- **Widget Patterns**: Follow existing widget implementation patterns
- **Event Handling**: Implement proper Qt signal/slot connections
- **Data Binding**: Efficiently bind data to GUI components
- **Progress Feedback**: Provide user feedback for long operations
- **Error Display**: Show user-friendly error messages

### 5. Testing and Validation
Implement comprehensive testing:

- **Database Testing**: Test with transaction rollback
- **Service Testing**: Test business logic with mocked dependencies
- **GUI Testing**: Test user interface with pytest-qt
- **Integration Testing**: Test complete workflows
- **Performance Testing**: Validate with large datasets

## genai-tag-db-tools Implementation Patterns

### Database Schema Implementation
Follow established schema patterns:

```python
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Boolean
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship

Base = declarative_base()

class TagsTable(Base):
    __tablename__ = 'tags'
    
    tag_id = Column(Integer, primary_key=True, autoincrement=True)
    source_tag = Column(String, nullable=False)
    tag = Column(String, nullable=False, unique=True)
    created_at = Column(DateTime, nullable=False)
    updated_at = Column(DateTime, nullable=False)
    
    # Relationships
    translations = relationship("TagTranslationsTable", back_populates="tag")
    usage_counts = relationship("TagUsageCountsTable", back_populates="tag")
    status_records = relationship("TagStatusTable", back_populates="tag")
```

### Repository Pattern Implementation
Use repository pattern for data access:

```python
from sqlalchemy.orm import Session
from typing import List, Optional
from genai_tag_db_tools.data.database_schema import TagsTable

class TagRepository:
    def __init__(self, session: Session):
        self.session = session
    
    def create_tag(self, tag_data: dict) -> TagsTable:
        """Create a new tag with proper validation."""
        tag = TagsTable(**tag_data)
        self.session.add(tag)
        self.session.flush()  # Get ID without committing
        return tag
    
    def get_tag_by_name(self, tag_name: str) -> Optional[TagsTable]:
        """Retrieve tag by name with case-insensitive search."""
        return self.session.query(TagsTable).filter(
            TagsTable.tag.ilike(tag_name)
        ).first()
    
    def search_tags(self, query: str, limit: int = 100) -> List[TagsTable]:
        """Search tags with fuzzy matching."""
        return self.session.query(TagsTable).filter(
            TagsTable.tag.contains(query)
        ).limit(limit).all()
```

### Service Layer Implementation
Implement business logic in service classes:

```python
from typing import List, Dict, Any
from sqlalchemy.orm import Session
from genai_tag_db_tools.data.tag_repository import TagRepository
from genai_tag_db_tools.data.database_schema import TagsTable

class TagManagementService:
    def __init__(self, session: Session):
        self.session = session
        self.tag_repository = TagRepository(session)
    
    def register_tag(
        self, 
        tag_name: str, 
        source_tag: str, 
        translations: Dict[str, str] = None
    ) -> TagsTable:
        """Register a new tag with validation and transaction management."""
        try:
            # Validate input
            self._validate_tag_input(tag_name, source_tag)
            
            # Check for duplicates
            existing_tag = self.tag_repository.get_tag_by_name(tag_name)
            if existing_tag:
                raise ValueError(f"Tag '{tag_name}' already exists")
            
            # Create tag
            tag_data = {
                'tag': tag_name,
                'source_tag': source_tag,
                'created_at': datetime.now(),
                'updated_at': datetime.now()
            }
            
            tag = self.tag_repository.create_tag(tag_data)
            
            # Add translations if provided
            if translations:
                self._add_translations(tag, translations)
            
            self.session.commit()
            return tag
            
        except Exception as e:
            self.session.rollback()
            raise
    
    def _validate_tag_input(self, tag_name: str, source_tag: str) -> None:
        """Validate tag input parameters."""
        if not tag_name or not tag_name.strip():
            raise ValueError("Tag name cannot be empty")
        if len(tag_name) > 255:
            raise ValueError("Tag name too long (max 255 characters)")
        # Additional validation logic
```

### GUI Widget Implementation
Follow PySide6 patterns for GUI components:

```python
from PySide6.QtWidgets import QWidget, QMessageBox
from PySide6.QtCore import Signal, QThread
from genai_tag_db_tools.gui.designer.TagRegisterWidget_ui import Ui_TagRegisterWidget
from genai_tag_db_tools.services.tag_management import TagManagementService

class TagRegisterWidget(QWidget):
    tag_registered = Signal(str)  # Emit when tag is successfully registered
    
    def __init__(self, tag_service: TagManagementService, parent=None):
        super().__init__(parent)
        self.ui = Ui_TagRegisterWidget()
        self.ui.setupUi(self)
        self.tag_service = tag_service
        self._setup_connections()
    
    def _setup_connections(self):
        """Set up signal/slot connections."""
        self.ui.register_button.clicked.connect(self._register_tag)
        self.ui.tag_name_edit.textChanged.connect(self._validate_input)
    
    def _register_tag(self):
        """Register new tag with error handling."""
        tag_name = self.ui.tag_name_edit.text().strip()
        source_tag = self.ui.source_tag_edit.text().strip()
        
        try:
            # Show progress
            self.ui.register_button.setEnabled(False)
            self.ui.status_label.setText("Registering tag...")
            
            # Register tag
            tag = self.tag_service.register_tag(tag_name, source_tag)
            
            # Success feedback
            self.ui.status_label.setText("Tag registered successfully!")
            self.tag_registered.emit(tag_name)
            self._clear_form()
            
        except Exception as e:
            # Error handling
            QMessageBox.critical(self, "Registration Error", str(e))
            self.ui.status_label.setText("Registration failed")
        finally:
            self.ui.register_button.setEnabled(True)
```

### Database Migration Implementation
Use Alembic for schema changes:

```python
"""Add tag aliases support

Revision ID: abc123def456
Revises: previous_revision
Create Date: 2024-01-01 12:00:00.000000

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers
revision = 'abc123def456'
down_revision = 'previous_revision'
branch_labels = None
depends_on = None

def upgrade():
    """Add tag aliases functionality."""
    # Add alias support to TAG_STATUS table
    op.add_column('tag_status', 
        sa.Column('alias', sa.Boolean(), nullable=False, default=False))
    op.add_column('tag_status', 
        sa.Column('preferred_tag_id', sa.Integer(), nullable=True))
    
    # Add foreign key constraint
    op.create_foreign_key(
        'fk_tag_status_preferred_tag',
        'tag_status', 'tags',
        ['preferred_tag_id'], ['tag_id']
    )
    
    # Add index for performance
    op.create_index('ix_tag_status_alias', 'tag_status', ['alias'])

def downgrade():
    """Remove tag aliases functionality."""
    op.drop_index('ix_tag_status_alias', 'tag_status')
    op.drop_constraint('fk_tag_status_preferred_tag', 'tag_status', type_='foreignkey')
    op.drop_column('tag_status', 'preferred_tag_id')
    op.drop_column('tag_status', 'alias')
```

### Bulk Operations Implementation
Optimize for large dataset operations:

```python
from typing import List, Dict
import polars as pl
from sqlalchemy.orm import Session

class BulkTagImportService:
    def __init__(self, session: Session):
        self.session = session
    
    def import_tags_from_csv(self, csv_path: str) -> Dict[str, int]:
        """Import tags from CSV with efficient bulk operations."""
        try:
            # Read CSV with Polars for performance
            df = pl.read_csv(csv_path)
            
            # Validate data
            self._validate_import_data(df)
            
            # Convert to records
            tag_records = df.to_dicts()
            
            # Bulk insert with batch processing
            batch_size = 1000
            inserted_count = 0
            skipped_count = 0
            
            for i in range(0, len(tag_records), batch_size):
                batch = tag_records[i:i + batch_size]
                batch_result = self._process_tag_batch(batch)
                inserted_count += batch_result['inserted']
                skipped_count += batch_result['skipped']
            
            self.session.commit()
            
            return {
                'inserted': inserted_count,
                'skipped': skipped_count,
                'total': len(tag_records)
            }
            
        except Exception as e:
            self.session.rollback()
            raise
    
    def _process_tag_batch(self, batch: List[Dict]) -> Dict[str, int]:
        """Process a batch of tags with duplicate checking."""
        # Implementation for batch processing
        pass
```

## Implementation Checklist

### Database Implementation
- [ ] Schema changes implemented with proper constraints
- [ ] Alembic migration created and tested
- [ ] Indexes added for performance-critical queries
- [ ] Foreign key relationships properly defined
- [ ] Data validation implemented at database level

### Service Layer Implementation
- [ ] Repository pattern used for data access
- [ ] Business logic properly encapsulated
- [ ] Transaction boundaries clearly defined
- [ ] Input validation implemented
- [ ] Error handling comprehensive

### GUI Implementation
- [ ] Qt Designer files properly integrated
- [ ] Signal/slot connections implemented
- [ ] User feedback provided for long operations
- [ ] Error messages user-friendly
- [ ] Form validation implemented

### Testing Implementation
- [ ] Unit tests for all service methods
- [ ] Database tests with transaction rollback
- [ ] GUI tests for user interactions
- [ ] Integration tests for complete workflows
- [ ] Performance tests for bulk operations

### Performance Implementation
- [ ] Database queries optimized
- [ ] Bulk operations use efficient methods
- [ ] Memory usage optimized for large datasets
- [ ] Progress feedback for long operations
- [ ] Caching implemented where appropriate

## Common Implementation Patterns

### Transaction Management
```python
from contextlib import contextmanager

@contextmanager
def database_transaction(session):
    """Context manager for database transactions."""
    try:
        yield session
        session.commit()
    except Exception:
        session.rollback()
        raise
    finally:
        session.close()
```

### Error Handling
```python
class TagOperationError(Exception):
    """Base exception for tag operations."""
    pass

class TagValidationError(TagOperationError):
    """Tag validation failed."""
    pass

class TagDuplicateError(TagOperationError):
    """Tag already exists."""
    pass
```

### Progress Reporting
```python
from PySide6.QtCore import QObject, Signal

class ProgressReporter(QObject):
    progress_updated = Signal(int)  # Progress percentage
    status_updated = Signal(str)    # Status message
    
    def report_progress(self, current: int, total: int, message: str = ""):
        percentage = int((current / total) * 100)
        self.progress_updated.emit(percentage)
        if message:
            self.status_updated.emit(message)
```

## Anti-Patterns to Avoid

### Database Anti-Patterns
- **Direct SQL in GUI**: Never put SQL queries in GUI components
- **Missing Transactions**: Always use transactions for multi-table operations
- **Poor Error Handling**: Don't ignore database exceptions
- **Missing Validation**: Always validate data before database operations
- **Inefficient Queries**: Avoid N+1 query problems

### Service Layer Anti-Patterns
- **Fat Controllers**: Keep GUI components thin, business logic in services
- **Direct Database Access**: Always use repository pattern
- **Mixed Concerns**: Don't mix validation, business logic, and data access
- **Poor Error Propagation**: Don't swallow exceptions without handling
- **Missing Logging**: Always log important operations and errors

### GUI Anti-Patterns
- **Blocking Operations**: Never block the GUI thread with long operations
- **Poor Error Display**: Always show user-friendly error messages
- **Missing Progress**: Provide progress feedback for long operations
- **Tight Coupling**: Don't directly access database from GUI components
- **Missing Validation**: Validate user input before processing